######################################################################
#
# Generalized EM algorithm for Gaussian Mixture Models to demonstrate 
# its steps using synthitic dataset generated by the code.
#
# After all iterations are complete, the code plots the mixture of
# Gaussians and corresponding contours.
#
######################################################################
#The codes are based on Python2.7. 
#Please install numpy, scipy, matplotlib packages before using.
#Thank you for your suggestions!
#
#@version 1.0
######################################################################
import matplotlib.pyplot as plt
import numpy as np
from scipy.cluster.vq import kmeans
from scipy.stats import multivariate_normal

m = 3000

A1 = np.concatenate((np.random.randn(1000, 1) * 0.1 + 5, np.random.randn(1000, 1) * 0.5 + 4), axis = 0)
A1 = np.concatenate((A1, np.random.randn(1000, 1) * 0.1 + 3), axis = 0)

A2 = np.concatenate((np.random.randn(1000, 1) * 1 + 9, np.random.randn(1000, 1) * 1 + 6), axis = 0)
A2 = np.concatenate((A2, np.random.randn(1000, 1) * 1 + 5), axis = 0)

A = np.concatenate((A1, A2), axis = 1)

data = A.T
K = 3 # Mixture of 3 Gaussians. 

plt.figure(1)
plt.scatter(A[:, 0], A[:, 1]) 

dim = data.shape[0]
dataNo = data.shape[1]

## Initialize using kmeans
C = kmeans(data.T, K)
mu = C[0].T
pi = np.zeros((1, K))
sigma = np.zeros((dim, dim, K))
for k in range(0, K):
    pi[0, k] = 1.0 / K 
    sigma[:,:,k] = np.eye(dim)

## Iteration
iter = 0
val = 0

for n in range(0, dataNo):
    tmp = 0
    for k in range(0, K):
        p = multivariate_normal.pdf(data[:,n], mu[:,k], sigma[:,:,k])
        tmp = tmp + pi[0, k] * p
    val = val + np.log(tmp)
    
while iter < 100:
    iter = iter + 1
    
    # Expectation step  
    R = np.zeros((dataNo, K))
    for n in range(0, dataNo):
        Rnk = np.zeros((1, K))
        for k in range(0, K):
                      
            Rnk[0,k] = pi[0, k] * multivariate_normal.pdf(data[:,n], mu[:,k], sigma[:,:,k])
        
        R[n,:] = Rnk / np.sum(Rnk)

    # Maximazation step   
    NK = np.sum(R, axis = 0)
    
    for k in range(0, K):
        
        mu[:,k] = 1.0 / NK[k] * data.dot(R[:, k])
        Ek = np.zeros((dim, dim))
        for n in range(0, dataNo):
            temp = data[:, n] - mu[:, k]
            temp = temp.reshape(temp.shape[0], 1)
            Ek = Ek + R[n, k] * (temp).dot(temp.T)
        sigma[:,:,k] = 1.0 / NK[k] * Ek
    
    pi = NK / dataNo
    pi = pi.reshape(1, pi.shape[0])
    
    ## convergence check
    newval = 0
    for n in range(0, dataNo):
        tmp = 0
        for k in range(0, K):
            p = multivariate_normal.pdf(data[:,n], mu[:,k], sigma[:,:,k])
            tmp = tmp + pi[0,k] * p
        newval = newval + np.log(tmp)
        
    print '...Iterator %d ...' % iter
    print np.abs(newval - val)
    print 'mu:'
    print mu
    print 'sigma:' 
    print sigma
        
    if (np.abs(newval - val) < np.power(10.0, -12)):
        print np.abs(newval - val)
        print 'mu:'
        print mu
        print 'sigma:'
        print sigma
        print 'parameters converged after %d iterations...' % iter
        break
    
    val = newval
    
    #Printing data every 10 iterations
    if (np.mod(iter + 1, 10) == 0):
        plt.figure()
        plt.scatter(A[:, 0], A[:, 1])
        plt.hold(True)
        X, Y = np.meshgrid(np.arange(2, 5.5 +0.02, 0.02), np.arange(2, 12+0.5, 0.5))
        for i in range(0, mu.shape[1]):
            
            tempX = X.ravel(order='F')
            tempX = tempX.reshape(tempX.shape[0], 1)
            tempY = Y.ravel(order='F')
            tempY = tempY.reshape(tempY.shape[0], 1)
            
            Z = multivariate_normal.pdf(np.concatenate((tempX, tempY), axis = 1), mean = mu[:, i].T, cov = sigma[:,:,i])
            Z = Z.reshape(1, Z.shape[0])
            Z = Z.reshape(X.shape[1], X.shape[0])
            Z = Z.T
            plt.contour(X, Y, Z)

plt.figure()
plt.scatter(A[:, 0], A[:, 1])
plt.hold(True)    
X, Y = np.meshgrid(np.arange(2, 5.5 +0.02, 0.02), np.arange(2, 12+0.5, 0.5))

for i in range(0, mu.shape[1]):
    tempX = X.ravel(order='F')
    tempX = tempX.reshape(tempX.shape[0], 1)
    tempY = Y.ravel(order='F')
    tempY = tempY.reshape(tempY.shape[0], 1)
    
    Z = multivariate_normal.pdf(np.concatenate((tempX, tempY), axis = 1), mean = mu[:, i].T, cov = sigma[:,:,i])
    Z = Z.reshape(1, Z.shape[0])
    Z = Z.reshape(X.shape[1], X.shape[0])
    Z = Z.T
    plt.contour(X, Y, Z, 6)   
plt.show() 